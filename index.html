<!doctype html>
<html>
  <head>
    <meta charset="utf8" />
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0;
      }
      body {
        box-sizing: border-box;
        padding: 24px;
      }
      * {
        font-size: 24px;
        line-height: 48px;
        font-family: monospace;
        margin: 0;
        padding: 0;
      }
      #src {
        width: 100%;
        height: 75%;
        border: none;
        resize: none;
        outline: none;
      }
      #output {
        width: 100%;
        height: 25%;
      }
      #target {
        display: inline-block;
        min-width: 200px;
        border: none;
        outline: none;
      }
    </style>
  </head>
  <body>
    <textarea id="src" class="language-python"></textarea>
    <div id="output">
      <div>Target: <input id="target" /></div>
      <div>Output: <span id="stdout"></span></div>
    </div>
    <script>
      let src = document.querySelector('textarea')
      let stdout = document.querySelector('#stdout')
      let target = document.querySelector('#target')
      let worker
      let timeout
      let executionId = 0

      function execute() {
        if (!worker || !window.pyodideReady) return

        const id = ++executionId
        stdout.textContent = ''

        if (timeout) clearTimeout(timeout)
        timeout = setTimeout(() => {
          if (id !== executionId) return
          worker.terminate()
          stdout.textContent = 'Timeout: Execution exceeded 100ms'
          initWorker()
        }, 100)

        worker.postMessage({ type: 'execute', code: src.value, id })
      }

      function finish() {
        if (stdout.textContent.includes('Traceback')) {
          const text = stdout.textContent.replace(/\r?\n/g, '⏎')
          const lines = text.split('⏎').map((l) => l.trim()).filter((l) => l && !l.startsWith('^') && !l.includes('Traceback'))
          const error = lines[lines.length - 1]
          const match = [...text.matchAll(/File "<exec>", line (\d+)/g)].pop()
          const line = match ? match[1] : ''
          stdout.textContent = (line ? 'line ' + line + ', ' : '') + error
        } else if (target.parentElement.style.display !== 'none' && target.value) {
          const canonical = (s) => s.replace(/[ \t\r\n⏎]+/g, ' ').trim()
          if (canonical(target.value) == canonical(stdout.textContent)) {
            stdout.textContent += '✔️'
          } else {
            stdout.textContent += '❌️'
          }
        }

        const params = new URLSearchParams()
        params.set('c', src.value)
        if (target.value) {
          params.set('t', target.value)
        }
        location.hash = '#' + params.toString()
      }

      src.addEventListener('keydown', (e) => {
        if (e.key == 'Tab') {
          e.preventDefault()
          src.setRangeText('    ', src.selectionStart, src.selectionEnd, 'end')
        }
      })

      function initWorker() {
        window.pyodideReady = false
        worker = new Worker('python.js')
        worker.onmessage = (e) => {
          if (e.data.type === 'ready') {
            window.pyodideReady = true
            execute()
          }
          if (e.data.id !== executionId && e.data.type !== 'ready') return
          if (e.data.type === 'stdout') {
            stdout.textContent += e.data.text.replace(/\r?\n/g, '⏎')
          }
          if (e.data.type === 'done' || e.data.type === 'error') {
            clearTimeout(timeout)
            if (e.data.type === 'error' && !stdout.textContent) {
              stdout.textContent = e.data.message.replace(/\r?\n/g, '⏎')
            }
            if (stdout.textContent.endsWith('⏎')) {
              stdout.textContent = stdout.textContent.slice(0, -1)
            }
            finish()
          }
        }
      }

      if (location.hash.length > 1) {
        const hash = location.hash.substring(1)
        if (hash.startsWith('c=') || hash.includes('&t=')) {
          const params = new URLSearchParams(hash)
          src.value = params.get('c') || ''
          target.value = (params.get('t') || '').replace(/\r?\n/g, '⏎')
        } else {
          try {
            const data = JSON.parse(atob(hash))
            src.value = data[0] || ''
            target.value = (data[1] || '').replace(/\r?\n/g, '⏎')
          } catch (e) {
            console.error('Failed to parse hash', e)
          }
        }

        if (!target.value) {
          target.parentElement.style.display = 'none'
        }
      }

      src.addEventListener('input', execute)
      target.addEventListener('input', execute)

      initWorker()
    </script>
  </body>
</html>
